package thoth.logic;

import java.util.ArrayList;
import java.util.Random;
public class Curve {
    private float fmb_min_movement;
    private float fbm_max_movement;
    private float chaos_factor;

    private float prev_value;
    private float prev_fbm;

    private Random rng;

    // Values are stored.
    private ArrayList<Integer> values; // Default horizon 0.

    /**
     * Creates a new curve generating stream with given parameters.

     * @param fbm_min_movement minimum FBM disturbance per time step.
     * @param fbm_max_movement maximum FMB disturbance per time step.
     * @param chaos_factor is a value between 0 and 1 indicating how chaotic the curve should be
    */
    public Curve(float fbm_min_movement, float fbm_max_movement, float chaos_factor) {
        this(fbm_min_movement, fbm_max_movement, chaos_factor, new Random().nextInt());
    }

    /**
     * Creates a new curve generating stream with given parameters.

     * @param fbm_min_movement minimum FBM disturbance per time step.
     * @param fbm_max_movement maximum FMB disturbance per time step.
     * @param chaos_factor is a value between 0 and 1 indicating how chaotic the curve should be
     * @param seed used in the RNG for reproducible results if needed.
    */
    public Curve(float fbm_min_movement, float fbm_max_movement, float chaos_factor, int seed) {
        this.rng = new Random(seed);
        this.chaos_factor = chaos_factor;
        this.fmb_min_movement = fbm_min_movement;
        this.fbm_max_movement = fbm_max_movement;

        this.prev_value = 0f;
        this.prev_fbm = 0f;

        this.values = new ArrayList<Integer>();
        this.values.add((int)this.rng.nextFloat(0f, 100f));
    }

    /**
     * @return the number of elapsed steps.
    */
    public int getSteps() {
        return this.values.size();
    }

    /**
     * Generates a curve with random parameters.
     */
    public static Curve generateCurve() {
        Random r = new Random();
        float fbm_min_movement = -5;
        float fbm_max_movement = 20;
        float chaos_factor = r.nextFloat(0, 1);

        return new Curve(fbm_min_movement, fbm_max_movement, chaos_factor);
    }

    /**
     * Gets the percentage change between the last two stored values.
     */
    public float getValueChangePercent() {
        if (this.values.size() < 2) return 0f;
        int lastValue = this.values.get(this.values.size() - 1);
        int prevValue = this.values.get(this.values.size() - 2);
        if (prevValue == 0) return 0f;
        return ((float)(lastValue - prevValue) / Math.abs((float)prevValue)) * 100f;
    }

    /**
     * Gets the next value generated by this curve.
     * @param event_effect the effect of an event on the base value of the curve.
     * @return the value of this curve at the next time step.
    */
    public float nextValue(float event_effect) {
        this.prev_fbm = rng.nextFloat(this.fmb_min_movement, this.fbm_max_movement) + (this.prev_fbm);
        this.prev_value += event_effect;

        return lerp(this.prev_value, this.prev_fbm, chaos_factor);
    }

    /**
     * Returns a sub-array of the current values, considering the offset for the beginning.
     * I.e., the interval [offset, lastValue].
     * If the offset = this.values.size() -1, the last value only is returned.
     */
    public int[] getLastValues(int offset) {
        int[] lastValues = new int[this.values.size() - offset];
        for (int i = offset; i < this.values.size(); i++) {
            lastValues[i - offset] = this.values.get(i);
        }
        return lastValues;
    }

    public void storeValue(float value) {
        this.values.add((int) value);
    }

    private float lerp(float a, float b, float factor) {
        return a * factor + b * (1f - factor);
    }
}
