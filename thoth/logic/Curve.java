package thoth.logic;

import java.util.ArrayList;
import java.util.Random;

public class Curve {
    private float fmb_min_movement;
    private float fbm_max_movement;
    private float chaos_factor;

    private float prev_value;
    private float prev_fbm;

    private Random rng;

    // Values are stored.
    private ArrayList<Integer> values; // Default horizon 0.

    /**
     * Creates a new curve generating stream with given parameters.

     * @param fbm_min_movement minimum FBM disturbance per time step.
     * @param fbm_max_movement maximum FMB disturbance per time step.
     * @param chaos_factor is a value between 0 and 1 indicating how chaotic the curve should be
    */
    public Curve(float fbm_min_movement, float fbm_max_movement, float chaos_factor) {
        this(fbm_min_movement, fbm_max_movement, chaos_factor, new Random().nextInt());
    }

    /**
     * Creates a new curve generating stream with given parameters.

     * @param fbm_min_movement minimum FBM disturbance per time step.
     * @param fbm_max_movement maximum FMB disturbance per time step.
     * @param chaos_factor is a value between 0 and 1 indicating how chaotic the curve should be
     * @param seed used in the RNG for reproducible results if needed.
    */
    public Curve(float fbm_min_movement, float fbm_max_movement, float chaos_factor, int seed) {
        this.rng = new Random(seed);
        this.chaos_factor = chaos_factor;
        this.fmb_min_movement = fbm_min_movement;
        this.fbm_max_movement = fbm_max_movement;

        this.prev_fbm = 0f;

        float startPrice = switch(rng.nextInt(4)) {
            case 0 -> rng.nextFloat(1500f, 4000f);  // Tech US
            case 1 -> rng.nextFloat(1200f, 2200f);  // Stable US
            case 2 -> rng.nextFloat(350f, 800f);    // Growth
            default -> rng.nextFloat(45f, 85f);     // Europe banque
        };
        
        this.values = new ArrayList<>();
        this.values.add((int)startPrice);
        this.prev_value = startPrice;
        this.prev_fbm = 0f;
        
        // Pré-génère 10 valeurs
        for (int i = 0; i < 10; i++) {
            storeValue(nextValue(rng.nextFloat(-80f, 120f))); // News effect réaliste
        }
    }

    /**
     * @return the number of elapsed steps.
    */
    public int getSteps() {
        return this.values.size() - 1; // -1, to have the last step as pre-generated (for AI).
    }

    /**
     * Generates a curve with random parameters.
     */
    public static Curve generateCurve() {
        Random r = new Random();
        
        // 4 archétypes bourse réalistes
        int type = r.nextInt(4);
        return switch (type) {
            case 0 -> new Curve(-250f, 250f, 0.85f, r.nextInt(100));
            case 1 -> new Curve(-140f, 140f, 0.45f, r.nextInt(100));
            case 2 -> new Curve(-180f, 180f, 0.78f, r.nextInt(100));
            case 3 -> new Curve(-80f, 80f, 0.32f, r.nextInt(100));
            default -> new Curve(-150f, 150f, 0.65f, r.nextInt(100));
        }; // Tech bull (Tesla-like) : +volatilité haute
        // Stable croissance (Apple-like)
        // Volatil cyclique (Netflix-like)
        // Stable défensif (BNP-like)
    }

    /**
     * Gets the percentage change between the last two stored values (without pregenerated).
     */
    public float getValueChangePercent() {
        if (this.getSteps() < 2) return 0f;
        int lastValue = this.values.get(this.getSteps() - 1);
        int prevValue = this.values.get(this.getSteps() - 2);
        if (prevValue == 0) return 0f;
        return ((float)(lastValue - prevValue) / Math.abs((float)prevValue)) * 100f;
    }

    /**
     * Gets the next value generated by this curve.
     * @param event_effect the effect of an event on the base value of the curve.
     * @return the value of this curve at the next time step.
    */
    public float nextValue(float event_effect) {
        this.prev_fbm = rng.nextFloat(this.fmb_min_movement, this.fbm_max_movement) + (this.prev_fbm);
        this.prev_value += event_effect;

        return Math.max(0f, lerp(this.prev_value, this.prev_fbm, chaos_factor));
    }

    /**
     * Returns a sub-array of the current values, considering the offset for the beginning.
     * I.e., the interval [offset, lastValue].
     * If the offset = this.values.size() -1, the last value only is returned.
     */
    public int[] getLastValues(int offset) {
        int[] lastValues = new int[this.values.size() - 1 - offset];
        for (int i = offset; i < this.values.size() - 1; i++) {
            lastValues[i - offset] = this.values.get(i);
        }
        return lastValues;
    }

    public int getPregeneratedValue() {
        return this.values.get(this.values.size() - 1);
    }

    public void storeValue(float value) {
        this.values.add((int) value);
    }

    private float lerp(float a, float b, float factor) {
        return a * factor + b * (1f - factor);
    }
}
