package thoth.logic;

import java.util.Random;
public class Curve {
    private float fmb_min_movement;
    private float fbm_max_movement;
    private float chaos_factor;

    private float prev_value;
    private float prev_fbm;

    private Random rng;

    private int elapsed_steps = 0; // Default horizon 0.
    /**
     * Creates a new curve generating stream with given parameters.

     * @param fbm_min_movement minimum FBM disturbance per time step.
     * @param fbm_max_movement maximum FMB disturbance per time step.
     * @param chaos_factor is a value between 0 and 1 indicating how chaotic the curve should be
    */
    public Curve(float fbm_min_movement, float fbm_max_movement, float chaos_factor) {
        this.rng = new Random();
        this.chaos_factor = chaos_factor;
        this.fmb_min_movement = fbm_min_movement;
        this.fbm_max_movement = fbm_max_movement;

        this.prev_value = 0f;
        this.prev_fbm = 0f;
    }

    /**
     * Creates a new curve generating stream with given parameters.

     * @param fbm_min_movement minimum FBM disturbance per time step.
     * @param fbm_max_movement maximum FMB disturbance per time step.
     * @param chaos_factor is a value between 0 and 1 indicating how chaotic the curve should be
     * @param seed used in the RNG for reproducible results if needed.
    */
    public Curve(float fbm_min_movement, float fbm_max_movement, float chaos_factor, int seed) {
        this.rng = new Random(seed);
        this.chaos_factor = chaos_factor;
        this.fmb_min_movement = fbm_min_movement;
        this.fbm_max_movement = fbm_max_movement;

        this.prev_value = 0f;
        this.prev_fbm = 0f;
    }

    /**
     * @return the number of elapsed steps.
    */
    public int getSteps() {
        return this.elapsed_steps;
    }

    /**
     * Generates a curve with random parameters.
     */
    public static Curve generateCurve() {
        Random r = new Random();
        float fbm_min_movement = r.nextFloat(0, 20);
        float fbm_max_movement = r.nextFloat(fbm_min_movement, 50);
        float chaos_factor = r.nextFloat(0, 1);

        return new Curve(fbm_min_movement, fbm_max_movement, chaos_factor);
    }

    /**
     * Gets the next value generated by this curve.
     * @param event_effect the effect of an event on the base value of the curve.
     * @return the value of this curve at the next time step.
    */
    public float nextValue(float event_effect) {
        this.prev_fbm = rng.nextFloat(this.fmb_min_movement, this.fbm_max_movement) + (this.prev_fbm);
        this.prev_value += event_effect;

        return lerp(this.prev_value, this.prev_fbm, chaos_factor);
    }

    private float lerp(float a, float b, float factor) {
        return a * factor + b * (1f - factor);
    }
}
